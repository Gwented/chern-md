// Back to the original idea. Optional syntax. Small md language.
// bind: main.chrn

var:
    name, str
    something, %Pika
    %gorpi, str$

// log:
    owners, Map<f64, str>
    pets, List<str>

    [args] [var_name], [args] [type] [cond]

    (We have to remake every last parsing feature inside of this to delegate in-language efforts.
    Second ver has the original just syntax forcing for ser and deser)

    name Org !isEmpty      (May still need & for the parsing to work but we'll see)
    age u8 2..=5&age==5|==5         (You can omit here too!)
    owners Map<f64, str>        (You can omit it!!)
    #ign cats lizards pets List<nil>        (Just stop before brackets to see if it's a type)
    rules:
        #nested pets #ign cats lizards 
        age 6..=7&age==!=7

// ser:

// deser:

    [Reasons to use this] General purpose MD language modifier, with type enforcement. Less tokens.

    It forces Engineers and agents to adhere to the exact syntax specified.
    This CAN be seen as a syntactic AI rules file but it isn't specifically for that purpose.

    (Made with Clap likely)

    [operators]
    And = &. Or = |. Not = !. NE = !=. True = true. False = false. Equal to = ==. Greater and stuff < <= > >=.
    any type = ?,
    Can be None = nil or ~nil(only Avoiding name conflicts. Possible opt-in only for ~nil). 
    
    if opt=~. ~nil, ~true, ~false, within output file (Chern only).

    [Types]
    u8, i8, u16, i16, u32, i32, f32, u64, i64, f64, bool, str, Obj, %SomeType, nil (or ~nil), List, Map
    Plain types: Integer=any integer, Float=any floating point, 

    POSSIBLE FOR OPERATOR REASONS BUT UNSURE: BigInt, BigDeci

    POSSIBLE FOR CONVENIENT TYPE INFERENCE: '?'
    #It will just take whatever type it got and fill in the '?' after parsing, or you can default it somehow.
    Example: name: ?. After parse -> name: u8 (found in program). Also could just mean you don't care, ever.

    [COMMAND LIST] 
    bind, var, log, nest, isEmpty(default value), isWhitespace (maybe), isNone, hasA x, startsW a, endsW m, opt=~, => (nesting)

    [SYNTAX]

    The 'var:' means you are defining variables.
    The 'log:' means you are defining specific logs you want.
    The 'logO:' means you want an output of the logs which you can specific the pathing for. 'logO: dir/some.chrn'

    To link it to a file you must use 'send' and the file path with a type. Maybe the cli part will change my structure
    of this a bit, for stuff like send being changed within it ignoring the initial send request, but we'll see.

    You can literally put the value you expect into the string slot but you have to tell me with an attribute maybe.
    Example: name #act_str Org 

    'Obj' is a filler keyword that just says expect a non-comforming data type, explicit custom 
    type ID enforcable so maybe something like, "Vec<Entity>".

    NotPresent variable = ~None. 

    Conditional examples = name str&!isEmpty or name !isNone for possible warns and errors.

    [Attributes] Global, Wide, Local

    #WErr, #IErr, (hold) #exp_str (req "literal"), #exp_var, #ign_err, (expand) #no_order, #edit, #pack, #middleground opt=~ ,
    #make (Makes file given if not present. exmpl: bind: #make some.json )

    // Idea for attribute args is to just give it a string that it builds and clears in specific scenarios
    // so that it just keeps them anyways for something like #WErr

    (Should we crash by default or warn by default? If so we would need CErr for crash on error)
    
    Warn on type errors =  WErr # Entirely omits crashing and now only warns |
    Ignore type errors = IErr # Lets you declare wrongly without type warns or crashes. Likely used for specific var |
    Ignore warn errors = IWErr | # Omits warns but still crashes
    
    Limit var to only as many as declared = #Limit
    Light checking so, if a singular variable in var is correct, it's still correct but will warn = #LC
    Can expect a specific var name = #exp_var something_else name str
    Can expect a specific var name on language = #exp_str -RUST _name_ -JAVA theName name str  
    Will expect no particular order = #unordered
    
    // Can expect a specific var name = #exp something_else name str
    Can expect a specific var name on language = #exp -RUST _name_ -JAVA theName name str///   
    (NOT DOING THIS WILL OTHERWISE KEEP ALL OTHER ATTRIBUTES)
    Ignore all prior encompassing error logic and only focus on the inline preceding logic = #IAll 
    
    [Special Features]

    !Range syntax!
    price 0..=5&>0&!=5 (Unsure of if we need != we'll see)

    !Unifying MD!
    Supports .json, .toml, .yml .yaml, .xml

    !Tags! (For langauge specific args)

    [Edge cases]

    Unicode support 

    Hex support 

    BigInt, BigDecimal

    Language specific attribute sections due to large amounts of type pain

    If unsignedness is used in Java, the user is forced to tell me what they want out of the parser
    since there is Java equivelant. I will just have to introduce "tags" that behave differently 
    based on the language, as to avoid different props files being required. I can either require the 
    tag rules of whicever language is being used as a complex proned but cleaner feature, or not recomended.

    There also needs to be better syntax for nesting. Like 'rules: model => parameters | model => data => |

    | = this is a part of the same var. => = go one level in.

    [CLI cmds] (Naming will get better for CLI cmds)
    Set all of X field to None. (setF)
    Sort fields (sortF) Asce -A Desc -D 
    Check if types are correct (type-check) --type-check [ID] name [expected] u8  
    
    Functional concepts like map that will alter the actual file it's attached to.


    [Possible features]
    (MORE IN NOTES OF COURSE)

    __This is starting to sound like a bad idea since our goal is to unify MD as a sole being, not do their job__
    Functional concepts? Like map or even farther for commands to be done beyond the cli. 
    Like, tax Vec<i64>.filter(num < 10 | num > 3).map(num * 2) or Vec<BigInt>.map() for complex tasks, idk.
    A big part of this is that you can omit something like num > 5 & < 10 &... since there can only be one ID.

    Type safety when serializing too? So, you could supply props file or likely, rules within props itself that it will
    give to the chrn parser so that it can be a type checker itself.
    Attributes would be 
    Warn on incorrect type serializing = SWErr | Crash on serializing incorrect type error = SCErr | 

    Since we have a props file? Maybe the parser can infer placing types if there is some sort of alignment error   
    if you give it enough explicit types. With an attribute that you could set to allow it for stuff like Obj
    by itself? So basically, trusting the parser with your life. 
    Realistically, this would be best fit for easier scenarios like if we have |
        "name: String, age: u8, pet Entity"| The parser can obviously infer that pet's type should be obj if 
        wrong in the props file. Maybe for both ser and de? Let's see eventually.

    Allowing boolean 'var:' logic? As in, age i32|i64. Unsure if this is even needed so omitted for now.

    Allow for multiple sends? Example: 'send some.chrn & thing.json'

    Language specific variable names expected? Example: #Rust some_thing #Java someThing (Yes)

    Language specific type mode? #RUSTSYN name Rc<RefCell<String>> #PYSYN name int

    Option for actual MD file type label? Basically having the top of the MD file just contain bounds for it being valid
    at the very top. Likely just a special feature for my MD since I can ignore it with the parser. #WITHBOUNDS

    It has a method table anyways? So allow for more readability in the future.

    Possible explicit nesting type checks? 
